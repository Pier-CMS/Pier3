Class {
	#name : #PRPierFrame,
	#superclass : #MAComponent,
	#instVars : [
		'context',
		'children'
	],
	#category : #'Pier-Seaside-Core'
}

{ #category : #testing }
PRPierFrame class >> canBeRoot [
	^ true
]

{ #category : #private }
PRPierFrame class >> classFromRequest: aRequest name: aString base: aBaseClass [
	| value |
	value := aRequest
		at: aString
		ifAbsent: [ ^ nil ].
	^ aBaseClass withAllConcreteClasses
		detect: [ :each | 
			each isAbstract not
				and: [ each name greaseString = value 
				or: [ each label = value ] ] ]
		ifNone: [ nil ]

]

{ #category : #registration }
PRPierFrame class >> configureApplication: application [
	application configuration
		addParent: PRPierConfiguration instance.
	application 
		addLibrary: PRBlueprintLibrary;
		addLibrary: PRJavaScriptSupport
]

{ #category : #registration }
PRPierFrame class >> description [
	^ 'Pier'
]

{ #category : #examples }
PRPierFrame class >> exampleDocumentation [
	"Create a (static) Pier instance from all the comments in the source code of pier, a sort of poor mans documentation. It might take a while to get all the classes traversed and to parse the source."

	^ self on: (PRContext kernel: self exampleDocumentationKernel)
]

{ #category : #examples }
PRPierFrame class >> exampleDocumentationKernel [
	"Create a Pier kernel from all the comments in the source code of pier, a sort of poor mans documentation. It might take a while to get all the classes traversed and to parse the source."

	^ PRKernel new
			name: 'Documentation';
			root: self exampleDocumentationRoot;
			yourself
]

{ #category : #examples }
PRPierFrame class >> exampleDocumentationRoot [
	^ (PRPage named: 'documentation')
		contents: 'Autogenerated documentation from the classes derived from the key base classes used within Pier: 
- *PRObject*
- *MAObject*';
		addChild: (self pageForClass: PRObject);
		addChild: (self pageForClass: MAObject);
		yourself
]

{ #category : #examples }
PRPierFrame class >> exampleEmpty [
	"Pier can be easily used as a component within any Seaside application, this is just an example of a dumb wiki. To see this example browse to /seaside/examples/examplebrowser and select the receiver class."

	^ self on: (PRContext kernel: (PRKernel new
		name: 'Pier';
		root: (PRPage new
			title: 'Pier Example';
			contents: 'Pier can be easily used as a component within any Seaside application (maybe you should adapt the style-sheets), this is just an example of a dumb and non-persistent wiki.';
			yourself)))
]

{ #category : #testing }
PRPierFrame class >> isAbstract [
	^ false
]

{ #category : #testing }
PRPierFrame class >> isDeployed [
	^ true
]

{ #category : #'instance creation' }
PRPierFrame class >> on: aContext [
	"This contructor creates a new SmallWiki frame that can be used within any Seaside application. It doesn't require a special session class, since all the required state is hold in the context of the wiki itself."

	^ self new
		context: aContext;
		yourself
]

{ #category : #examples }
PRPierFrame class >> pageForClass: aClass [ 
	| page |
	page := (PRPage named: aClass name)
		contents: (String streamContents: 
				[ :stream | 
				stream
					nextPutAll: '!Class definition';
					nextPut: Character cr.
				aClass definition linesDo: 
					[ :each | 
					(GRPlatform current magritteClassNamed: #SPHighlightedCode) isNil 
						ifTrue: [ stream nextPut: $= ]
						ifFalse: [ stream nextPutAll: '==' ].
					stream
						nextPutAll: each;
						nextPut: Character cr ].
				aClass hasComment ifTrue: 
					[ stream
						nextPutAll: '!Class comment';
						nextPut: Character cr.
					stream
						nextPutAll: aClass comment;
						nextPut: Character cr ].
				aClass selectorsAndMethodsDo: 
					[ :selector :method | 
					(aClass firstCommentAt: selector) ifNotEmptyDo: 
						[ :comment | 
						stream
							nextPutAll: '!!';
							nextPutAll: selector;
							nextPut: Character cr.
						stream
							nextPutAll: comment;
							nextPut: Character cr;
							nextPut: Character cr ] ] ]);
		yourself.
	aClass subclassesDo: [ :each | page addChild: (self pageForClass: each) ].
	^ page
]

{ #category : #registration }
PRPierFrame class >> registerAsApplication: aString kernel: aKernel [
	"self registerAsApplication: 'pier' kernel: (PRKernel instanceNamed: 'pier')"

	| app |
	app := WAAdmin register: self asApplicationAt: aString.
	self configureApplication: app.
	app preferenceAt: #kernel put: aKernel.
	^ app
]

{ #category : #visiting }
PRPierFrame >> acceptDecorated: aPainterVisitor [
	"Catch any actions done with visitors and make sure they have a context.
	This is hacky because it is really only needed for the initial render when
	the PRContextFilter is not in the dynamic context. This might be fixable.
	Note that this is not used with callback processing; see PRContextFilter."

	self withContextDo: [ super acceptDecorated: aPainterVisitor ]
]

{ #category : #processing }
PRPierFrame >> addContextFilter [
	self session 
		addFilter: (PRContextFilter on: self)
]

{ #category : #private }
PRPierFrame >> buildChildren [
	^ Set new
		addAll: (self componentsOf: self environment);
		addAll: (self componentsOf: self structure);
		yourself
]

{ #category : #'accessing-dynamic' }
PRPierFrame >> children [
	^ children ifNil: [ children := self buildChildren ]
]

{ #category : #private }
PRPierFrame >> componentsOf: aStructure [
	^ aStructure componentsIn: self context
]

{ #category : #accessing }
PRPierFrame >> context [
	"Answer the current context of Pier, initialize with a default context if nil."

	^ context ifNil: [ context := PRContext kernel: self kernel ]
]

{ #category : #accessing }
PRPierFrame >> context: aContext [
	aContext isValid
		ifFalse: [ ^ self forbidden: aContext ].
	context := aContext.
	children := nil.
	self update
]

{ #category : #'accessing-dynamic' }
PRPierFrame >> environment [
	^ self context structure environment
]

{ #category : #'processing-errors' }
PRPierFrame >> forbidden: aContext [
	"This method is called whenever aContext is forbidden to be accessed. If everything fails, we show a plain error notification."
	
	| error |
	error := aContext
		structure: aContext structure
		view: PRForbiddenView.
	[ error structure isRoot or: [ error isValid ] ] whileFalse: [ 
		error := error
			structure: error structure parent
			view: PRForbiddenView ].
	error command viewComponent 
		forbidden: aContext copy.
	error isValid
		ifTrue: [ self context: error ]
		ifFalse: [
			self requestContext responseGenerator
				forbidden;
				respond ]
]

{ #category : #processing }
PRPierFrame >> initialRequest: aRequest [
	| structure following |
	super initialRequest: aRequest.
	self addContextFilter.
	following := self context
		structure: (structure := self 
			parseStructure: aRequest 
			ifAbsent: [ ^ self notFound ])
		command: (self
			parseCommand: aRequest
			structure: structure).
	following command
		initialRequest: aRequest.
	self context: following
]

{ #category : #'accessing-dynamic' }
PRPierFrame >> kernel [
	^ self application preferenceAt: #kernel
]

{ #category : #'processing-errors' }
PRPierFrame >> notFound [
	"This method is called whenever the current request cannot be resolved to a structure."
	
	self context: (self context
		structure: self context root
		view: PRNotFoundView)
]

{ #category : #processing }
PRPierFrame >> parseCommand: aRequest structure: aStructure [
	| commandClass |
	commandClass := self class 
		classFromRequest: aRequest 
		name: 'command'
		base: PRCommand.
	(commandClass isNil or: [ commandClass isAbstract ])
		ifTrue: [ commandClass := aStructure defaultCommandClass ].
	^ commandClass new
]

{ #category : #processing }
PRPierFrame >> parseStructure: aRequest ifAbsent: aBlock [
	| path consumer pathString |
	path := OrderedCollection new.
	consumer := self requestContext consumer.
	[ consumer atEnd ] whileFalse: [ path add: consumer next ].
	pathString := String
		streamContents: [ :stream | 
			path
				do: [ :pageName | 
					stream
						nextPut: $/;
						nextPutAll: pageName ] ].
	^ self context root lookupPath: pathString ifAbsent: aBlock
]

{ #category : #rendering }
PRPierFrame >> renderContentOn: html [
	html rendererInstance
		start: self environment
		in: self on: html
]

{ #category : #private }
PRPierFrame >> rendererForRoot: aHtmlRoot [
	^ self rendererClass context: aHtmlRoot context
]

{ #category : #'accessing-dynamic' }
PRPierFrame >> states [
	^ Array with: self
]

{ #category : #'accessing-dynamic' }
PRPierFrame >> structure [
	^ self context structure
]

{ #category : #updating }
PRPierFrame >> update [
	self visiblePresentersDo: [ :each | each onChangeContext: self context ]
]

{ #category : #updating }
PRPierFrame >> updateBody: aHtmlRoot [
	aHtmlRoot bodyAttributes addClass: self structure cssClass.
	aHtmlRoot meta name: 'generator'; content: 'Pier - Magritte - Seaside'
]

{ #category : #'updating-extras' }
PRPierFrame >> updateCanonical: aHtmlRoot [
	"Defines the canonical URL, the URL for the current page that should be used when search engines index or when people bookmark the current page."

	aHtmlRoot link
		relationship: 'canonical';
		url: self context url
]

{ #category : #updating }
PRPierFrame >> updateDtd: aHtmlRoot [
	aHtmlRoot docType: '<!DOCTYPE HTML>'
]

{ #category : #'updating-extras' }
PRPierFrame >> updateIcon: aHtmlRoot [
	| structure |
	structure := self structure icon ifNil: [ ^ self ].
	structure file isNil ifTrue: [ ^ self ].
	aHtmlRoot link
		beShortcutIcon;
		type: structure file mimetype;
		url: structure file url
]

{ #category : #'updating-extras' }
PRPierFrame >> updateNavigation: aHtmlRoot [
	| siblings index |
	siblings := self context siblings.
	index := siblings indexOf: self structure.
	self structure isRoot ifFalse: [
		self 
			updateRelationship: 'top'
			with: self structure root
			on: aHtmlRoot ].
	self
		updateRelationship: 'up'
		with: self structure parent
		on: aHtmlRoot.
	self 
		updateRelationship: 'first'
		with: siblings first
		on: aHtmlRoot.
	self 
		updateRelationship: 'previous'
		with: (siblings at: index - 1 ifAbsent: [ nil ])
		on: aHtmlRoot.
	self 
		updateRelationship: 'next'
		with: (siblings at: index + 1 ifAbsent: [ nil ])
		on: aHtmlRoot.
	self 
		updateRelationship: 'last'
		with: siblings last
		on: aHtmlRoot
]

{ #category : #'updating-extras' }
PRPierFrame >> updateRelationship: aString with: aStructure on: aHtmlRoot [
	| target renderer |
	(aStructure isNil or: [ aStructure = self structure])
		ifTrue: [ ^ self ].
	target := self context structure: aStructure.
	target isValid ifFalse: [ ^ self ].
	renderer := self rendererForRoot: aHtmlRoot.
	aHtmlRoot link
		relationship: aString; 
		url: (target urlOn: renderer)
]

{ #category : #updating }
PRPierFrame >> updateRoot: aHtmlRoot [
	super updateRoot: aHtmlRoot.
	self
		updateDtd: aHtmlRoot;
		updateBody: aHtmlRoot;
		updateStyleSheets: aHtmlRoot;
		updateNavigation: aHtmlRoot;
		updateCanonical: aHtmlRoot;
		updateIcon: aHtmlRoot
]

{ #category : #'updating-extras' }
PRPierFrame >> updateStyleSheets: aHtmlRoot [
	self structure styleSheets do: [ :structure |
		aHtmlRoot stylesheet url: structure url ]
]

{ #category : #updating }
PRPierFrame >> updateUrl: anUrl [
	super updateUrl: anUrl.
	anUrl adaptToContext: self context
]

{ #category : #private }
PRPierFrame >> withContextDo: aBlock [
	^ PRCurrentContextHolder use: self during: aBlock
]
